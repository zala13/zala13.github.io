{"posts":[{"title":"Introduction","text":"个人信息我是 ZALA，目前就读于哈尔滨工业大学（深圳），坐标广东深圳。 虽然阴差阳错选择了电气工程及其自动化专业，但对 Code 持有着真诚且炽热的心！ 技术栈核心技术 Java：熟练掌握Java核心技术，包括集合框架、多线程、IO 流等，了解设计模式和 JVM 基础知识 C++：扎实的面向对象编程基础，熟悉STL容器和算法，了解内存管理和多线程编程 后端开发 熟悉常见的后端开发框架、数据库设计与优化、常用中间件，熟练掌握 Git、Maven、IDEA等主流开发工具 完成社区项目，正在学习微服务 AI应用开发 熟悉 AI 应用开发的核心技术要点，如 RAG 知识库构建与检索、Agent 架构设计、提示词工程、MCP等 完成 RAG 知识库开发、Agent 边缘设备本地部署 目标 后端开发：构建高性能、可扩展的后端服务，参与系统架构设计和优化 AI 应用开发：将人工智能技术落地到实际应用中，开发智能产品和服务 联系我 GitHub：zala13 Email：zalainsz@outlook.com","link":"/2025/12/12/Introduction/"},{"title":"","text":"测试文章：没有Front-matter这是一篇没有添加Front-matter的测试文章，用于验证Hexo是否会将其显示在主页上。","link":"/2025/12/17/test-no-front-matter/"},{"title":"","text":"","link":"/2025/12/17/leetcode/%E6%A0%88/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"},{"title":"","text":"单链表的倒数第 k 个节点从前往后寻找单链表的第 k 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 k 个节点呢？ 那你可能说，假设链表有 n 个节点，倒数第 k 个节点就是正数第 n - k + 1 个节点，不也是一个 for 循环的事儿吗？ 是的，但是算法题一般只给你一个 ListNode 头结点代表一条单链表，你不能直接得出这条链表的长度 n，而需要先遍历一遍链表算出 n 的值，然后再遍历链表计算第 n - k + 1 个节点。 也就是说，这个解法需要遍历两次链表才能得到出倒数第 k 个节点。 那么，我们能不能只遍历一次链表，就算出倒数第 k 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。 这个解法就比较巧妙了，假设 k = 2，思路如下： 首先，我们先让一个指针 p1 指向链表的头节点 head，然后走 k 步： 现在的 p1，只要再走 n - k 步，就能走到链表末尾的空指针了对吧？ 趁这个时候，再用一个指针 p2 指向链表头节点 head： 接下来就很显然了，让 p1 和 p2 同时向前走，p1 走到链表末尾的空指针时前进了 n - k 步，p2 也从 head 开始前进了 n - k 步，停留在第 n - k + 1 个节点上，即恰好停链表的倒数第 k 个节点上： 这样，只遍历了一次链表，就获得了倒数第 k 个节点 p2。 上述逻辑的代码如下： javacpppythongojavascript // 返回链表的倒数第 k 个节点ListNode findFromEnd(ListNode head, int k) { ListNode p1 = head; // p1 先走 k 步 for (int i = 0; i &lt; k; i++) { p1 = p1.next; } ListNode p2 = head; // p1 和 p2 同时走 n - k 步 while (p1 != null) { p2 = p2.next; p1 = p1.next; } // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点 return p2;}你可以点开下面的可视化面板，代码将计算倒数第二个节点。多次点击 即可看到快指针 p1 先前进了 2 步，然后多次点击 这一行代码，即可看到 p1 和 p2 同时前进，最终 p2 停在了倒数第 k 个节点上： 算法可视化面板当然，如果用 big O 表示法来计算时间复杂度，无论遍历一次链表和遍历两次链表的时间复杂度都是O(N)O(N)，但上述这个算法更有技巧性。 很多链表相关的算法题都会用到这个技巧，比如说力扣第 19 题「删除链表的倒数第 N 个结点」： 删除链表的倒数第 N 个结点 | 力扣 | LeetCode | 🟠给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： 输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]示例 2： 输入：head = [1], n = 1输出：[]示例 3： 输入：head = [1,2], n = 1输出：[1]提示： 链表中结点的数目为 sz1 &lt;= sz &lt;= 300 &lt;= Node.val &lt;= 1001 &lt;= n &lt;= sz进阶：你能尝试使用一趟扫描实现吗？ 题目来源：力扣 19. 删除链表的倒数第 N 个结点。我们直接看解法代码： javacpppythongojavascript class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { // 虚拟头结点 ListNode dummy = new ListNode(-1); dummy.next = head; // 删除倒数第 n 个，要先找倒数第 n + 1 个节点 ListNode x = findFromEnd(dummy, n + 1); // 删掉倒数第 n 个节点 x.next = x.next.next; return dummy.next; } private ListNode findFromEnd(ListNode head, int k) { // 代码见上文 } }你可以打开可视化面板，点击 这一行代码一次，可以看到 p2 先前进了 k 步，然后多次点击 这一行代码，可以看到 p1 和 p2 同时前进，最终 p2 停在了倒数第 k 个节点上： 算法可视化面板这个逻辑就很简单了，要删除倒数第 n 个节点，就得获得倒数第 n + 1 个节点的引用，可以用我们实现的 findFromEnd 来操作。 不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。 但有了我们虚拟节点 dummy 的存在，就避免了这个问题，能够对这种情况进行正确的删除。","link":"/2025/12/17/leetcode/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7%E9%97%AE%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"title":"","text":"","link":"/2025/12/17/leetcode/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"title":"","text":"","link":"/2025/12/17/leetcode/%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/n%E6%95%B0%E4%B9%8B%E5%92%8C-2%E3%80%8115/"},{"title":"","text":"","link":"/2025/12/17/leetcode/%E5%93%88%E5%B8%8C%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"","text":"","link":"/2025/12/17/leetcode/DFS(traceback)/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"title":"","text":"","link":"/2025/12/17/leetcode/DFS(traceback)/22.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"title":"","text":"21合并两个有序链表这是最基本的链表技巧，力扣第 21 题「合并两个有序链表」就是这个问题，给你输入两个有序链表，请你把他俩合并成一个新的有序链表： 合并两个有序链表 | 力扣 | LeetCode | 🟢将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]示例 2： 输入：l1 = [], l2 = []输出：[]示例 3： 输入：l1 = [], l2 = [0]输出：[0]提示： 两个链表的节点数目范围是 [0, 50]-100 &lt;= Node.val &lt;= 100l1 和 l2 均按 非递减顺序 排列题目来源：力扣 21. 合并两个有序链表。javacpppythongojavascript // 函数签名如下ListNode mergeTwoLists(ListNode l1, ListNode l2);这题比较简单，我们直接看解法： javacpppythongojavascript class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 虚拟头结点 ListNode dummy = new ListNode(-1), p = dummy; ListNode p1 = l1, p2 = l2; while (p1 != null &amp;&amp; p2 != null) { // 比较 p1 和 p2 两个指针 // 将值较小的的节点接到 p 指针 if (p1.val &gt; p2.val) { p.next = p2; p2 = p2.next; } else { p.next = p1; p1 = p1.next; } // p 指针不断前进 p = p.next; } if (p1 != null) { p.next = p1; } if (p2 != null) { p.next = p2; } return dummy.next; } }我们的 while 循环每次比较 p1 和 p2 的大小，把较小的节点接到结果链表上，看如下 GIF： 形象地理解，这个算法的逻辑类似于拉拉链，l1, l2 类似于拉链两侧的锯齿，指针 p 就好像拉链的拉索，将两个有序链表合并。 下面是算法的可视化，你可以多次点击 这一行代码，即可看到 合并两个有序链表的过程： 算法可视化面板代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 dummy 节点。你可以试试，如果不使用 dummy 虚拟节点，代码会复杂一些，需要额外处理指针 p 为空的情况。而有了 dummy 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。 23合并 k 个有序链表看下力扣第 23 题「合并K个升序链表」： 合并 K 个升序链表 | 力扣 | LeetCode | 🔴给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6示例 2： 输入：lists = []输出：[]示例 3： 输入：lists = [[]]输出：[]提示： k == lists.length0 &lt;= k &lt;= 10^40 &lt;= lists[i].length &lt;= 500-10^4 &lt;= lists[i][j] &lt;= 10^4lists[i] 按 升序 排列lists[i].length 的总和不超过 10^4题目来源：力扣 23. 合并 K 个升序链表。javacpppythongojavascript // 函数签名如下ListNode mergeKLists(ListNode[] lists);合并 k 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 k 个节点中的最小节点，接到结果链表上？ 这里我们就要用到优先级队列这种数据结构，把链表节点放入一个最小堆，就可以每次获得 k 个节点中的最小节点。关于优先级队列可以参考 优先级队列（二叉堆）原理及实现，本文不展开。 javacpppythongojavascript class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) return null; // 虚拟头结点 ListNode dummy = new ListNode(-1); ListNode p = dummy; // 优先级队列，最小堆 PriorityQueue pq = new PriorityQueue&lt;&gt;( lists.length, (a, b)-&gt;(a.val - b.val)); // 将 k 个链表的头结点加入最小堆 for (ListNode head : lists) { if (head != null) pq.add(head); } while (!pq.isEmpty()) { // 获取最小节点，接到结果链表中 ListNode node = pq.poll(); p.next = node; if (node.next != null) { pq.add(node.next); } // p 指针不断前进 p = p.next; } return dummy.next; } }你可以点开下面的可视化面板，点击 这一行代码，即可看到有序链表合并的过程： 算法可视化面板这个算法是面试常考题，它的时间复杂度是多少呢？ 优先队列 pq 中的元素个数最多是kk，所以一次 poll 或者 add 方法的时间复杂度是O(logk)O(logk)；所有的链表节点都会被加入和弹出 pq，所以算法整体的时间复杂度是O(Nlogk)O(Nlogk)，其中kk 是链表的条数，NN 是这些链表的节点总数。 但在这里还可以用分治算法","link":"/2025/12/17/leetcode/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8-21%E3%80%8123/"},{"title":"接雨水问题-11、42","text":"参考题目42. 接雨水 42. 接雨水 | 力扣 | LeetCode | 🔴 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 12输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2：12输入：height = [4,2,0,3,2,5]输出：9 提示： n == height.length 1 &lt;= n &lt;= 2 * 10⁴ 0 &lt;= height[i] &lt;= 10⁵ 解法暴力解法 → 备忘录解法 → 双指针解法 暴力解法-核心思路仅仅考虑位置 i 这一个位置能装下多少水？ 能装 2 格水，为什么位置 i 最多能盛 2 格水呢？因为，位置 i 能达到的水柱高度和其左边的最高柱子、右边的最高柱子有关，我们分别称这两个柱子高度为 l_max 和 r_max；位置 i 最大的水柱高度就是 min(l_max, r_max)。 也就是对于位置 i，能够装的水为： 123456water[i] = min( # 左边最高的柱子 max(height[0..i]), # 右边最高的柱子 max(height[i..end]) ) - height[i] 基于此，暴力写法： 12345678910111213141516171819class Solution { public int trap(int[] height) { int n = height.length; int res = 0; for (int i = 1; i &lt; n - 1; i++) { int l_max = 0, r_max = 0; // 找右边最高的柱子 for (int j = i; j &lt; n; j++) r_max = Math.max(r_max, height[j]); // 找左边最高的柱子 for (int j = i; j &gt;= 0; j--) l_max = Math.max(l_max, height[j]); // 如果自己就是最高的话， // l_max == r_max == height[i] res += Math.min(l_max, r_max) - height[i]; } return res; }} 时间复杂度 O(N²)，空间复杂度 O(1)。但是很明显这种计算 r_max 和 l_max 的方式非常笨拙 备忘录优化开两个数组 r_max 和 l_max 充当备忘录，l_max[i] 表示位置 i 左边最高的柱子高度，r_max[i] 表示位置 i 右边最高的柱子高度。预先把这两个数组计算好，避免重复计算： 12345678910111213141516171819202122232425class Solution { public int trap(int[] height) { if (height.length == 0) { return 0; } int n = height.length; int res = 0; // 数组充当备忘录 int[] l_max = new int[n]; int[] r_max = new int[n]; // 初始化 base case l_max[0] = height[0]; r_max[n - 1] = height[n - 1]; // 从左向右计算 l_max for (int i = 1; i &lt; n; i++) l_max[i] = Math.max(height[i], l_max[i - 1]); // 从右向左计算 r_max for (int i = n - 2; i &gt;= 0; i--) r_max[i] = Math.max(height[i], r_max[i + 1]); // 计算答案 for (int i = 1; i &lt; n - 1; i++) res += Math.min(l_max[i], r_max[i]) - height[i]; return res; }} 把时间复杂度降低为 O(N)，已经是最优了，但是空间复杂度是 O(N) 双指针解法用双指针边走边算，节省下空间复杂度。 12345678910111213141516171819202122class Solution { public int trap(int[] height) { int left = 0, right = height.length - 1; int l_max = 0, r_max = 0; int res = 0; while (left &lt; right) { l_max = Math.max(l_max, height[left]); r_max = Math.max(r_max, height[right]); // res += min(l_max, r_max) - height[i] if (l_max &lt; r_max) { res += l_max - height[left]; left++; } else { res += r_max - height[right]; right--; } } return res; }} 对于下图的情况，我们已经知道 l_max &lt; r_max 了，至于这个 r_max 是不是右边最大的，不重要。重要的是 height[i] 能够装的水只和较低的 l_max 之差有关，所以此处自然计算的是 left 柱所能接收雨水： 拓展题目11. 盛最多水的容器 11. 盛最多水的容器 | 力扣 | LeetCode | 🟠 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 示例 1：12输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2：12输入：height = [1,1]输出：1 提示： n == height.length 2 &lt;= n &lt;= 10⁵ 0 &lt;= height[i] &lt;= 10⁴ 题目来源：力扣 11. 盛最多水的容器。 思路和接雨水问题很类似，可以完全套用前文的思路，而且还更简单。两道题的区别在于： 接雨水问题给出的类似一幅直方图，每个横坐标都有宽度，而本题给出的每个横坐标是一条竖线，没有宽度。 前文讨论了半天 l_max 和 r_max，实际上都是为了计算 height[i] 能够装多少水；而本题中 height[i] 没有了宽度，那自然就好办多了。 举个例子，如果在接雨水问题中，你知道了 height[left] 和 height[right] 的高度，你能算出 left 和 right 之间能够盛下多少水吗？ 不能，因为你不知道 left 和 right 之间每个柱子具体能盛多少水，你得通过每个柱子的 l_max 和 r_max 来计算才行。 反过来，就本题而言，你知道了 height[left] 和 height[right] 的高度，能算出 left 和 right 之间能够盛下多少水吗？ 可以，因为本题中竖线没有宽度，所以 left 和 right 之间能够盛的水就是： 1min(height[left], height[right]) * (right - left) 解决这道题的思路依然是双指针技巧： 双指针用 left 和 right 两个指针从两端向中心收缩，一边收缩一边计算 [left, right] 之间的矩形面积，取最大的面积值即是答案。 注意，收缩的操作本就是为了寻找更大的面积，所以应该把 left 和 right 更小的一边先进行收缩，期望能够找到更高的边代替，进而能够更新最大面积 123456789101112131415161718class Solution { public int maxArea(int[] height) { int left = 0, right = height.length - 1; int res = 0; while (left &lt; right) { // [left, right] 之间的矩形面积 int cur_area = Math.min(height[left], height[right]) * (right - left); res = Math.max(res, cur_area); // 双指针技巧，移动较低的一边 if (height[left] &lt; height[right]) { left++; } else { right--; } } return res; }}","link":"/2025/12/14/leetcode/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98-11%E3%80%8142/"},{"title":"LeetCode 3. 无重复字符的最长子串","text":"无重复字符的最长子串题目描述给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 10^4 s 由英文字母、数字、符号和空格组成 解题思路这道题的最优解法是使用 滑动窗口 算法，通过维护一个滑动窗口 window （通常为 Map 类型）来记录当前不包含重复字符的子串，并且较为简单，不需要保存 need 。 核心思路 使用两个指针 left 和 right 分别表示滑动窗口的左右边界 使用哈希表（HashMap）记录窗口内的字符及其出现次数 右指针 right 不断向右移动，将当前字符加入窗口 如果当前字符在窗口中已经存在（出现次数大于1），则左指针 left 向右移动，直到窗口中不再包含重复字符 每次移动右指针时，更新最长子串的长度 算法步骤 初始化 left = 0，right = 0，maxLength = 0 创建一个哈希表 window 来存储字符及其出现次数 右指针 right 遍历字符串： 将当前字符 s[right] 加入窗口，更新其出现次数 如果当前字符出现次数大于1，则左指针 left 向右移动，同时减少对应字符的出现次数，直到当前字符出现次数等于1 更新最长子串长度：maxLength = max(maxLength, right - left + 1) 返回 maxLength 代码实现Java 实现1234567891011121314151617181920212223import java.util.HashMap;class Solution { public int lengthOfLongestSubstring(String s) { if (s.length() == 0) { return 0; } HashMap&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); int maxLength = 0; int left = 0, right = 0; for ( ; right &lt; s.length(); right++) { char curChar = s.charAt(right); window.put(curChar, window.getOrDefault(curChar, 0) + 1); while (window.get(curChar) &gt; 1 &amp;&amp; left &lt;= right) { char deleteChar = s.charAt(left); window.put(deleteChar, window.get(deleteChar) - 1); left++; } maxLength = Math.max(right - left + 1, maxLength); } return maxLength; }} C++ 实现1234567891011121314151617181920212223242526#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;class Solution {public: int lengthOfLongestSubstring(std::string s) { if (s.size() == 1) { return 1; } int left = 0, right = 0; std::unordered_map&lt;char, int&gt; win; int res = 0; while (right &lt; s.size()) { char ch = s[right]; win[ch]++; while (win[ch] &gt; 1) { win[s[left]]--; left++; } res = std::max(res, right - left + 1); right++; } return res; }}; 复杂度分析 时间复杂度： O(n)，其中 n 是字符串的长度。左指针和右指针分别最多移动 n 次。 空间复杂度： O(min(m, n))，其中 m 是字符集的大小。哈希表最多需要存储 m 个不同的字符。 总结这道题是滑动窗口算法的经典应用。通过维护一个动态调整的窗口，我们可以在一次遍历中找到最长无重复字符子串，时间复杂度为 O(n)。 同时还可以看到，C++ 和 Java 语言在 Map 接口上使用的不同，Java 更喜欢用 Map.xxx(key, val) 方法来获取默认值，而 C++ 则更倾向于使用 Map[index] 运算符。 滑动窗口算法是解决字符串相关问题的常用技巧，特别是在处理子串、子数组等连续问题时非常有效。","link":"/2025/12/13/leetcode/%E5%93%88%E5%B8%8C%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"title":"LeetCode 链表交换节点问题（24、25题）","text":"LeetCode 链表交换节点问题本文将详细讲解 LeetCode 中两道经典的链表节点交换问题： 第 24 题：两两交换链表中的节点 第 25 题：K 个一组翻转链表 这两道题都属于链表操作的经典题目，考察了对链表指针操作的掌握程度，以及递归或迭代思想的应用。 24. 两两交换链表中的节点题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例： 12输入：head = [1,2,3,4]输出：[2,1,4,3] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 解题思路这道题的最优解法是使用 迭代 方法，通过维护几个关键指针来实现两两节点的交换。 核心思路： 使用一个虚拟头节点（dummy node）简化边界情况处理 维护一个当前指针 curr，用于遍历链表 每次交换 curr 后面的两个节点 更新指针位置，继续下一轮交换 算法步骤： 创建虚拟头节点 dummy，使其指向原链表头 初始化当前指针 curr 指向 dummy 当 curr 后面有至少两个节点时： 保存要交换的两个节点 node1 和 node2 执行交换操作：node1.next = node2.next，node2.next = node1 更新 curr.next 指向交换后的新头节点 node2 将 curr 移动到 node1，准备下一轮交换 返回虚拟头节点的下一个节点 代码实现12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode swapPairs(ListNode head) { if (head == null) { return null; } ListNode dummy = new ListNode(-1); dummy.next = head; ListNode curr = dummy; while (curr != null &amp;&amp; curr.next != null &amp;&amp; curr.next.next != null) { ListNode node1 = curr.next, node2 = curr.next.next; node1.next = node2.next; node2.next = node1; curr.next = node2; curr = node1; } return dummy.next; }} 代码讲解 边界处理：如果链表为空，直接返回 null 创建虚拟头节点：dummy 节点的 next 指向原链表头，用于简化边界情况 初始化当前指针：curr 指向 dummy，作为当前交换位置的前一个节点 循环条件：当 curr 后面有至少两个节点时，继续交换 保存节点：node1 是当前要交换的第一个节点，node2 是第二个节点 交换操作： node1.next = node2.next：将 node1 指向 node2 原来的下一个节点 node2.next = node1：将 node2 指向 node1，完成两个节点的交换 更新指针： curr.next = node2：将当前指针的下一个节点指向交换后的新头节点 node2 curr = node1：将当前指针移动到 node1，准备下一轮交换 返回结果：返回虚拟头节点的下一个节点，即交换后的链表头 复杂度分析 时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次 空间复杂度：O(1)，只使用了常数级别的额外空间 25. K 个一组翻转链表题目描述给你链表的头节点 head，每 k 个节点一组进行翻转，请你返回修改后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 示例： 12输入：head = [1,2,3,4,5], k = 2输出：[2,1,4,3,5] 提示： 链表中的节点数目在范围 [0, 5000] 内 0 &lt;= Node.val &lt;= 1000 1 &lt;= k &lt;= 5000 解题思路这道题是第 24 题的升级版，需要以 k 个节点为一组进行翻转。同样可以使用 迭代 方法来解决。 核心思路： 使用虚拟头节点简化边界情况 维护三个指针：prev（当前组的前一个节点）、curr（当前节点）、succ（当前组的后一个节点） 先检查剩余节点是否足够 k 个 如果足够，对当前组的 k 个节点进行翻转 更新指针位置，继续下一组翻转 算法步骤： 创建虚拟头节点 dummy，使其指向原链表头 初始化 prev 指向 dummy，curr 指向原链表头 循环处理链表： 检查剩余节点是否足够 k 个 如果不足，跳出循环 如果足够，找到当前组的尾节点和下一组的头节点 翻转当前组的 k 个节点 更新指针位置，连接翻转后的链表 返回虚拟头节点的下一个节点 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode reverseKGroup(ListNode head, int k) { if (head == null) { return null; } ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy, curr = head; while (curr!= null) { ListNode succ = prev; int cnt = 0; while (cnt &lt; k) { if (succ.next == null) { break; } succ = succ.next; cnt++; } if (cnt != k) { break; } succ = succ.next; ListNode start = prev; ListNode end = prev.next; prev = prev.next; curr = curr.next; while (curr != succ) { ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; } start.next = prev; end.next = succ; prev = end; curr = prev.next; } return dummy.next; }} 代码讲解 边界处理：如果链表为空，直接返回 null 创建虚拟头节点：dummy 节点的 next 指向原链表头 初始化指针：prev 指向 dummy，curr 指向原链表头 检查剩余节点： 使用 succ 指针从 prev 开始移动 k 步 如果移动过程中遇到 null，说明剩余节点不足 k 个，跳出循环 记录位置： succ 指向当前组的下一个节点 start 是当前组的前一个节点 end 是当前组翻转前的头节点（翻转后的尾节点） 翻转当前组： 使用 prev 和 curr 指针进行翻转 每次将 curr 的下一个节点指向 prev，然后更新 prev 和 curr 连接链表： start.next = prev：将当前组的前一个节点指向翻转后的头节点 end.next = succ：将翻转后的尾节点指向原当前组的下一个节点 更新指针： prev = end：将 prev 指向翻转后的尾节点 curr = prev.next：将 curr 指向下一组的头节点 返回结果：返回虚拟头节点的下一个节点 复杂度分析 时间复杂度：O(n)，其中 n 是链表的长度。每个节点最多被访问两次 空间复杂度：O(1)，只使用了常数级别的额外空间 总结这两道题都是链表操作的经典题目，考察了对链表指针的熟练掌握程度。它们的共同特点是： 使用 虚拟头节点 简化边界情况处理 维护多个指针来跟踪当前操作的位置 进行节点的实际交换，而不是仅仅改变节点的值 保持指针的正确指向，避免链表断裂","link":"/2025/12/13/leetcode/%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E9%97%AE%E9%A2%98/%E4%BA%A4%E6%8D%A2%E8%8A%82%E7%82%B9-24%E3%80%8125/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/12/12/hello-world/"}],"tags":[{"name":"Introductiont","slug":"Introductiont","link":"/tags/Introductiont/"},{"name":"Test","slug":"Test","link":"/tags/Test/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"categories":[{"name":"Personal","slug":"Personal","link":"/categories/Personal/"},{"name":"Test","slug":"Test","link":"/categories/Test/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"LeetCode","slug":"技术/LeetCode","link":"/categories/%E6%8A%80%E6%9C%AF/LeetCode/"}],"pages":[{"title":"","text":"/** * 生成包含指定字符的 SVG 矢量图 * @param {string} text - 要显示的字符（如 \"ZALA13\"） * @param {Object} options - 可选配置（字体、颜色、尺寸等） * @returns {string} SVG 字符串 */ function generateTextSVG(text, options = {}) { // 默认配置 const config = { width: options.width || 300, // SVG 宽度 height: options.height || 150, // SVG 高度 fontSize: options.fontSize || 48, // 字体大小 fontFamily: options.fontFamily || 'Arial, Helvetica, sans-serif', // 字体 fill: options.fill || '#000000', // 字符颜色 stroke: options.stroke || 'none', // 描边（none 为无） strokeWidth: options.strokeWidth || 1, // 描边宽度 textAlign: options.textAlign || 'center', // 文字对齐方式 verticalAlign: options.verticalAlign || 'middle' // 垂直对齐 }; // 计算文字垂直居中的 y 坐标（SVG 中 y 轴向下，需结合字体大小计算） let y; if (config.verticalAlign === 'middle') { y = config.height / 2 + config.fontSize / 3.5; // 补偿字体基线偏移 } else if (config.verticalAlign === 'top') { y = config.fontSize; } else { y = config.height - 10; // bottom } // 拼接 SVG 字符串 const svg = ` ${text} `.trim(); return svg; } // ===================== 用法示例 ===================== // 1. 生成 \"ZALA13\" 的 SVG const zalaSvg = generateTextSVG(\"ZALA13\", { width: 400, // 自定义宽度 height: 200, // 自定义高度 fontSize: 60, // 更大的字体 fill: \"#2c3e50\", // 深蓝色文字 stroke: \"#ecf0f1\", // 浅灰色描边 strokeWidth: 2 // 描边宽度 }); // 2. 打印 SVG 内容（可直接复制到文本文件，保存为 .svg 格式） console.log(zalaSvg); // 3. 浏览器环境下：自动下载 SVG 文件（可选） if (typeof document !== 'undefined') { const blob = new Blob([zalaSvg], { type: 'image/svg+xml' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'ZALA13.svg'; // 下载的文件名 a.click(); URL.revokeObjectURL(url); // 释放资源 }","link":"/img/codeToSvg/svg-generator.js"}]}