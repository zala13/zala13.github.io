{"posts":[{"title":"Introduction","text":"个人信息我是 ZALA，目前就读于哈尔滨工业大学（深圳），坐标广东深圳。 虽然阴差阳错选择了电气工程及其自动化专业，但对 Code 持有着真诚且炽热的心！ 技术栈核心技术 Java：熟练掌握Java核心技术，包括集合框架、多线程、IO 流等，了解设计模式和 JVM 基础知识 C++：扎实的面向对象编程基础，熟悉STL容器和算法，了解内存管理和多线程编程 后端开发 熟悉常见的后端开发框架、数据库设计与优化、常用中间件，熟练掌握 Git、Maven、IDEA等主流开发工具 完成社区项目，正在学习微服务 AI应用开发 熟悉 AI 应用开发的核心技术要点，如 RAG 知识库构建与检索、Agent 架构设计、提示词工程、MCP等 完成 RAG 知识库开发、Agent 边缘设备本地部署 目标 后端开发：构建高性能、可扩展的后端服务，参与系统架构设计和优化 AI 应用开发：将人工智能技术落地到实际应用中，开发智能产品和服务 联系我 GitHub：zala13 Email：zalainsz@outlook.com","link":"/2025/12/12/Introduction/"},{"title":"LeetCode 3. 无重复字符的最长子串","text":"无重复字符的最长子串题目描述给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 10^4 s 由英文字母、数字、符号和空格组成 解题思路这道题的最优解法是使用 滑动窗口 算法，通过维护一个滑动窗口 window （通常为 Map 类型）来记录当前不包含重复字符的子串，并且较为简单，不需要保存 need 。 核心思路 使用两个指针 left 和 right 分别表示滑动窗口的左右边界 使用哈希表（HashMap）记录窗口内的字符及其出现次数 右指针 right 不断向右移动，将当前字符加入窗口 如果当前字符在窗口中已经存在（出现次数大于1），则左指针 left 向右移动，直到窗口中不再包含重复字符 每次移动右指针时，更新最长子串的长度 算法步骤 初始化 left = 0，right = 0，maxLength = 0 创建一个哈希表 window 来存储字符及其出现次数 右指针 right 遍历字符串： 将当前字符 s[right] 加入窗口，更新其出现次数 如果当前字符出现次数大于1，则左指针 left 向右移动，同时减少对应字符的出现次数，直到当前字符出现次数等于1 更新最长子串长度：maxLength = max(maxLength, right - left + 1) 返回 maxLength 代码实现Java 实现1234567891011121314151617181920212223import java.util.HashMap;class Solution { public int lengthOfLongestSubstring(String s) { if (s.length() == 0) { return 0; } HashMap&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); int maxLength = 0; int left = 0, right = 0; for ( ; right &lt; s.length(); right++) { char curChar = s.charAt(right); window.put(curChar, window.getOrDefault(curChar, 0) + 1); while (window.get(curChar) &gt; 1 &amp;&amp; left &lt;= right) { char deleteChar = s.charAt(left); window.put(deleteChar, window.get(deleteChar) - 1); left++; } maxLength = Math.max(right - left + 1, maxLength); } return maxLength; }} C++ 实现1234567891011121314151617181920212223242526#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;class Solution {public: int lengthOfLongestSubstring(std::string s) { if (s.size() == 1) { return 1; } int left = 0, right = 0; std::unordered_map&lt;char, int&gt; win; int res = 0; while (right &lt; s.size()) { char ch = s[right]; win[ch]++; while (win[ch] &gt; 1) { win[s[left]]--; left++; } res = std::max(res, right - left + 1); right++; } return res; }}; 复杂度分析 时间复杂度： O(n)，其中 n 是字符串的长度。左指针和右指针分别最多移动 n 次。 空间复杂度： O(min(m, n))，其中 m 是字符集的大小。哈希表最多需要存储 m 个不同的字符。 总结这道题是滑动窗口算法的经典应用。通过维护一个动态调整的窗口，我们可以在一次遍历中找到最长无重复字符子串，时间复杂度为 O(n)。 同时还可以看到，C++ 和 Java 语言在 Map 接口上使用的不同，Java 更喜欢用 Map.xxx(key, val) 方法来获取默认值，而 C++ 则更倾向于使用 Map[index] 运算符。 滑动窗口算法是解决字符串相关问题的常用技巧，特别是在处理子串、子数组等连续问题时非常有效。","link":"/2025/12/12/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/12/12/hello-world/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"Introductiont","slug":"Introductiont","link":"/tags/Introductiont/"},{"name":"Test","slug":"Test","link":"/tags/Test/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Personal","slug":"Personal","link":"/categories/Personal/"},{"name":"Test","slug":"Test","link":"/categories/Test/"}],"pages":[{"title":"","text":"/** * 生成包含指定字符的 SVG 矢量图 * @param {string} text - 要显示的字符（如 \"ZALA13\"） * @param {Object} options - 可选配置（字体、颜色、尺寸等） * @returns {string} SVG 字符串 */ function generateTextSVG(text, options = {}) { // 默认配置 const config = { width: options.width || 300, // SVG 宽度 height: options.height || 150, // SVG 高度 fontSize: options.fontSize || 48, // 字体大小 fontFamily: options.fontFamily || 'Arial, Helvetica, sans-serif', // 字体 fill: options.fill || '#000000', // 字符颜色 stroke: options.stroke || 'none', // 描边（none 为无） strokeWidth: options.strokeWidth || 1, // 描边宽度 textAlign: options.textAlign || 'center', // 文字对齐方式 verticalAlign: options.verticalAlign || 'middle' // 垂直对齐 }; // 计算文字垂直居中的 y 坐标（SVG 中 y 轴向下，需结合字体大小计算） let y; if (config.verticalAlign === 'middle') { y = config.height / 2 + config.fontSize / 3.5; // 补偿字体基线偏移 } else if (config.verticalAlign === 'top') { y = config.fontSize; } else { y = config.height - 10; // bottom } // 拼接 SVG 字符串 const svg = ` ${text} `.trim(); return svg; } // ===================== 用法示例 ===================== // 1. 生成 \"ZALA13\" 的 SVG const zalaSvg = generateTextSVG(\"ZALA13\", { width: 400, // 自定义宽度 height: 200, // 自定义高度 fontSize: 60, // 更大的字体 fill: \"#2c3e50\", // 深蓝色文字 stroke: \"#ecf0f1\", // 浅灰色描边 strokeWidth: 2 // 描边宽度 }); // 2. 打印 SVG 内容（可直接复制到文本文件，保存为 .svg 格式） console.log(zalaSvg); // 3. 浏览器环境下：自动下载 SVG 文件（可选） if (typeof document !== 'undefined') { const blob = new Blob([zalaSvg], { type: 'image/svg+xml' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'ZALA13.svg'; // 下载的文件名 a.click(); URL.revokeObjectURL(url); // 释放资源 }","link":"/img/codeToSvg/svg-generator.js"}]}