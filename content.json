{"posts":[{"title":"Introduction","text":"个人信息我是 ZALA，目前就读于哈尔滨工业大学（深圳），坐标广东深圳。 虽然阴差阳错选择了电气工程及其自动化专业，但对 Code 持有着真诚且炽热的心！ 技术栈核心技术 Java：熟练掌握Java核心技术，包括集合框架、多线程、IO 流等，了解设计模式和 JVM 基础知识 C++：扎实的面向对象编程基础，熟悉STL容器和算法，了解内存管理和多线程编程 后端开发 熟悉常见的后端开发框架、数据库设计与优化、常用中间件，熟练掌握 Git、Maven、IDEA等主流开发工具 完成社区项目，正在学习微服务架构 AI应用开发 熟悉 AI 应用开发的核心技术要点，如 RAG 知识库构建与检索、Agent 架构设计、提示词工程、MCP等 完成 RAG 知识库开发、Agent 边缘设备本地部署 联系我 GitHub：zala13 Email：zalainsz@outlook.com","link":"/2025/12/12/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%20Introduction/"},{"title":"下一个排列","text":"题目整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。 必须 原地 修改，只允许使用额外常数空间。 思路这道题目其实是 Hot100 系列题目比较有独特思想的，主要有两个重点。 下一个排列的实现可以分为以下几个步骤： 从右向左找到第一个位置 i，使得 nums[i] &lt; nums[i+1]。这个位置称为 pivot（枢纽）。注意：我们从倒数第二个开始向左找。 如果找到了这样的 i（i &gt;= 0），说明存在下一个排列；否则数组为完全降序，已经是最大排列。 从右向左找到第一个 j，使得 nums[j] &gt; nums[i]。因为 i 右侧是降序的，所以从右向左第一个大于 nums[i] 的元素实际上是比 nums[i] 大的最小元素，交换后能得到刚好比原排列大的排列。 交换 nums[i] 与 nums[j]。 由于 i 右侧原先是降序（或 i &lt; 0 时是整个数组），交换后仍是降序。我们要把它变为升序（最小顺序），只需反转 i+1 到末尾的子数组。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution { public void nextPermutation(int[] nums) { // 目标：将数组就地修改为字典序的下一个排列 // 下面的实现使用经典四步法，并附带详细中文注释，便于理解。 if (nums == null || nums.length &lt;= 1) return; // 1) 从右向左找到第一个位置 i，使得 nums[i] &lt; nums[i+1] // 这个位置称为 pivot（枢纽）。注意：我们从倒数第二个开始向左找。 int i = nums.length - 2; while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) { // 这里用 &gt;= 保证我们跳过后缀中非递增的部分（即降序部分） i--; } // 如果找到了这样的 i（i &gt;= 0），说明存在下一个排列；否则数组为完全降序，已经是最大排列 if (i &gt;= 0) { // 2) 从右向左找到第一个 j，使得 nums[j] &gt; nums[i] // 因为 i 右侧是降序的，所以从右向左第一个大于 nums[i] 的元素 // 实际上是比 nums[i] 大的最小元素，交换后能得到刚好比原排列大的排列 int j = nums.length - 1; while (j &gt; i &amp;&amp; nums[j] &lt;= nums[i]) { j--; } // 3) 交换 nums[i] 与 nums[j] swap(nums, i, j); } // 4) 由于 i 右侧原先是降序（或 i &lt; 0 时是整个数组），交换后仍是降序 // 我们要把它变为升序（最小顺序），只需反转 i+1 到末尾的子数组 reverse(nums, i + 1, nums.length - 1); } // 交换辅助方法 private void swap(int[] nums, int a, int b) { int t = nums[a]; nums[a] = nums[b]; nums[b] = t; } // 反转区间 [l, r] private void reverse(int[] nums, int l, int r) { while (l &lt; r) { swap(nums, l, r); l++; r--; } }}","link":"/2025/12/18/leetcode/31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"},{"title":"基础思维代码","text":"介绍本文会持续介绍一些考察非算法的手撕代码，包括但不限于基础思维代码、数据结构代码、算法代码等。 死锁死锁一直是常在学习计算机编程相关知识时需要特别注意的问题，下面是一个简单的死锁示例代码： 1234567891011121314151617181920212223242526272829303132333435363738public class DeadLockDemo { // 定义两把锁对象 private static final Object LOCK_A = new Object(); private static final Object LOCK_B = new Object(); public static void main(String[] args) { // 线程1：先获取LOCK_A，再尝试获取LOCK_B new Thread(() -&gt; { synchronized (LOCK_A) { System.out.println(Thread.currentThread().getName() + &quot; 持有锁A，尝试获取锁B&quot;); try { // 模拟业务耗时，放大死锁概率 Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } synchronized (LOCK_B) { System.out.println(Thread.currentThread().getName() + &quot; 获取锁B，执行完成&quot;); } } }, &quot;线程1&quot;).start(); // 线程2：先获取LOCK_B，再尝试获取LOCK_A new Thread(() -&gt; { synchronized (LOCK_B) { System.out.println(Thread.currentThread().getName() + &quot; 持有锁B，尝试获取锁A&quot;); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } synchronized (LOCK_A) { System.out.println(Thread.currentThread().getName() + &quot; 获取锁A，执行完成&quot;); } } }, &quot;线程2&quot;).start(); }} 上述代码最后会输出： 12线程1 持有锁A，尝试获取锁B线程2 持有锁B，尝试获取锁A 可以看到，线程1和线程2都在等待对方释放锁，从而导致死锁。","link":"/2025/12/18/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%9D%9E%E7%AE%97%E6%B3%95%E6%89%8B%E6%92%95/%E5%9F%BA%E7%A1%80%E6%80%9D%E7%BB%B4%E4%BB%A3%E7%A0%81/"},{"title":"LeetCode 链表交换节点问题（24、25题）","text":"本文将详细讲解 LeetCode 中两道经典的链表节点交换问题： 第 24 题：两两交换链表中的节点 第 25 题：K 个一组翻转链表 这两道题都属于链表操作的经典题目，考察了对链表指针操作的掌握程度，以及递归或迭代思想的应用。 24. 两两交换链表中的节点题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例： 12输入：head = [1,2,3,4]输出：[2,1,4,3] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 解题思路这道题的最优解法是使用 迭代 方法，通过维护几个关键指针来实现两两节点的交换。 核心思路： 使用一个虚拟头节点（dummy node）简化边界情况处理 维护一个当前指针 curr，用于遍历链表 每次交换 curr 后面的两个节点 更新指针位置，继续下一轮交换 算法步骤： 创建虚拟头节点 dummy，使其指向原链表头 初始化当前指针 curr 指向 dummy 当 curr 后面有至少两个节点时： 保存要交换的两个节点 node1 和 node2 执行交换操作：node1.next = node2.next，node2.next = node1 更新 curr.next 指向交换后的新头节点 node2 将 curr 移动到 node1，准备下一轮交换 返回虚拟头节点的下一个节点 代码实现12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode swapPairs(ListNode head) { if (head == null) { return null; } ListNode dummy = new ListNode(-1); dummy.next = head; ListNode curr = dummy; while (curr != null &amp;&amp; curr.next != null &amp;&amp; curr.next.next != null) { ListNode node1 = curr.next, node2 = curr.next.next; node1.next = node2.next; node2.next = node1; curr.next = node2; curr = node1; } return dummy.next; }} 代码讲解 边界处理：如果链表为空，直接返回 null 创建虚拟头节点：dummy 节点的 next 指向原链表头，用于简化边界情况 初始化当前指针：curr 指向 dummy，作为当前交换位置的前一个节点 循环条件：当 curr 后面有至少两个节点时，继续交换 保存节点：node1 是当前要交换的第一个节点，node2 是第二个节点 交换操作： node1.next = node2.next：将 node1 指向 node2 原来的下一个节点 node2.next = node1：将 node2 指向 node1，完成两个节点的交换 更新指针： curr.next = node2：将当前指针的下一个节点指向交换后的新头节点 node2 curr = node1：将当前指针移动到 node1，准备下一轮交换 返回结果：返回虚拟头节点的下一个节点，即交换后的链表头 复杂度分析 时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次 空间复杂度：O(1)，只使用了常数级别的额外空间 25. K 个一组翻转链表题目描述给你链表的头节点 head，每 k 个节点一组进行翻转，请你返回修改后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 示例： 12输入：head = [1,2,3,4,5], k = 2输出：[2,1,4,3,5] 提示： 链表中的节点数目在范围 [0, 5000] 内 0 &lt;= Node.val &lt;= 1000 1 &lt;= k &lt;= 5000 解题思路这道题是第 24 题的升级版，需要以 k 个节点为一组进行翻转。同样可以使用 迭代 方法来解决。 核心思路： 使用虚拟头节点简化边界情况 维护三个指针：prev（当前组的前一个节点）、curr（当前节点）、succ（当前组的后一个节点） 先检查剩余节点是否足够 k 个 如果足够，对当前组的 k 个节点进行翻转 更新指针位置，继续下一组翻转 算法步骤： 创建虚拟头节点 dummy，使其指向原链表头 初始化 prev 指向 dummy，curr 指向原链表头 循环处理链表： 检查剩余节点是否足够 k 个 如果不足，跳出循环 如果足够，找到当前组的尾节点和下一组的头节点 翻转当前组的 k 个节点 更新指针位置，连接翻转后的链表 返回虚拟头节点的下一个节点 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode reverseKGroup(ListNode head, int k) { if (head == null) { return null; } ListNode dummy = new ListNode(-1); dummy.next = head; ListNode prev = dummy, curr = head; while (curr!= null) { ListNode succ = prev; int cnt = 0; while (cnt &lt; k) { if (succ.next == null) { break; } succ = succ.next; cnt++; } if (cnt != k) { break; } succ = succ.next; ListNode start = prev; ListNode end = prev.next; prev = prev.next; curr = curr.next; while (curr != succ) { ListNode next = curr.next; curr.next = prev; prev = curr; curr = next; } start.next = prev; end.next = succ; prev = end; curr = prev.next; } return dummy.next; }} 代码讲解 边界处理：如果链表为空，直接返回 null 创建虚拟头节点：dummy 节点的 next 指向原链表头 初始化指针：prev 指向 dummy，curr 指向原链表头 检查剩余节点： 使用 succ 指针从 prev 开始移动 k 步 如果移动过程中遇到 null，说明剩余节点不足 k 个，跳出循环 记录位置： succ 指向当前组的下一个节点 start 是当前组的前一个节点 end 是当前组翻转前的头节点（翻转后的尾节点） 翻转当前组： 使用 prev 和 curr 指针进行翻转 每次将 curr 的下一个节点指向 prev，然后更新 prev 和 curr 连接链表： start.next = prev：将当前组的前一个节点指向翻转后的头节点 end.next = succ：将翻转后的尾节点指向原当前组的下一个节点 更新指针： prev = end：将 prev 指向翻转后的尾节点 curr = prev.next：将 curr 指向下一组的头节点 返回结果：返回虚拟头节点的下一个节点 复杂度分析 时间复杂度：O(n)，其中 n 是链表的长度。每个节点最多被访问两次 空间复杂度：O(1)，只使用了常数级别的额外空间 总结这两道题都是链表操作的经典题目，考察了对链表指针的熟练掌握程度。它们的共同特点是： 使用 虚拟头节点 简化边界情况处理 维护多个指针来跟踪当前操作的位置 进行节点的实际交换，而不是仅仅改变节点的值 保持指针的正确指向，避免链表断裂","link":"/2025/12/17/leetcode/%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E9%97%AE%E9%A2%98/%E4%BA%A4%E6%8D%A2%E8%8A%82%E7%82%B9-24%E3%80%8125/"},{"title":"LeetCode 3. 无重复字符的最长子串","text":"无重复字符的最长子串题目描述给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 10^4 s 由英文字母、数字、符号和空格组成 解题思路这道题的最优解法是使用 滑动窗口 算法，通过维护一个滑动窗口 window （通常为 Map 类型）来记录当前不包含重复字符的子串，并且较为简单，不需要保存 need 。 核心思路 使用两个指针 left 和 right 分别表示滑动窗口的左右边界 使用哈希表（HashMap）记录窗口内的字符及其出现次数 右指针 right 不断向右移动，将当前字符加入窗口 如果当前字符在窗口中已经存在（出现次数大于1），则左指针 left 向右移动，直到窗口中不再包含重复字符 每次移动右指针时，更新最长子串的长度 算法步骤 初始化 left = 0，right = 0，maxLength = 0 创建一个哈希表 window 来存储字符及其出现次数 右指针 right 遍历字符串： 将当前字符 s[right] 加入窗口，更新其出现次数 如果当前字符出现次数大于1，则左指针 left 向右移动，同时减少对应字符的出现次数，直到当前字符出现次数等于1 更新最长子串长度：maxLength = max(maxLength, right - left + 1) 返回 maxLength 代码实现Java 实现1234567891011121314151617181920212223import java.util.HashMap;class Solution { public int lengthOfLongestSubstring(String s) { if (s.length() == 0) { return 0; } HashMap&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); int maxLength = 0; int left = 0, right = 0; for ( ; right &lt; s.length(); right++) { char curChar = s.charAt(right); window.put(curChar, window.getOrDefault(curChar, 0) + 1); while (window.get(curChar) &gt; 1 &amp;&amp; left &lt;= right) { char deleteChar = s.charAt(left); window.put(deleteChar, window.get(deleteChar) - 1); left++; } maxLength = Math.max(right - left + 1, maxLength); } return maxLength; }} C++ 实现1234567891011121314151617181920212223242526#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;class Solution {public: int lengthOfLongestSubstring(std::string s) { if (s.size() == 1) { return 1; } int left = 0, right = 0; std::unordered_map&lt;char, int&gt; win; int res = 0; while (right &lt; s.size()) { char ch = s[right]; win[ch]++; while (win[ch] &gt; 1) { win[s[left]]--; left++; } res = std::max(res, right - left + 1); right++; } return res; }}; 复杂度分析 时间复杂度： O(n)，其中 n 是字符串的长度。左指针和右指针分别最多移动 n 次。 空间复杂度： O(min(m, n))，其中 m 是字符集的大小。哈希表最多需要存储 m 个不同的字符。 总结这道题是滑动窗口算法的经典应用。通过维护一个动态调整的窗口，我们可以在一次遍历中找到最长无重复字符子串，时间复杂度为 O(n)。 同时还可以看到，C++ 和 Java 语言在 Map 接口上使用的不同，Java 更喜欢用 Map.xxx(key, val) 方法来获取默认值，而 C++ 则更倾向于使用 Map[index] 运算符。 滑动窗口算法是解决字符串相关问题的常用技巧，特别是在处理子串、子数组等连续问题时非常有效。","link":"/2025/12/13/leetcode/%E5%93%88%E5%B8%8C%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"title":"接雨水问题-11、42","text":"参考题目42. 接雨水 42. 接雨水 | 力扣 | LeetCode | 🔴 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 12输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2：12输入：height = [4,2,0,3,2,5]输出：9 提示： n == height.length 1 &lt;= n &lt;= 2 * 10⁴ 0 &lt;= height[i] &lt;= 10⁵ 解法暴力解法 → 备忘录解法 → 双指针解法 暴力解法-核心思路仅仅考虑位置 i 这一个位置能装下多少水？ 能装 2 格水，为什么位置 i 最多能盛 2 格水呢？因为，位置 i 能达到的水柱高度和其左边的最高柱子、右边的最高柱子有关，我们分别称这两个柱子高度为 l_max 和 r_max；位置 i 最大的水柱高度就是 min(l_max, r_max)。 也就是对于位置 i，能够装的水为： 123456water[i] = min( # 左边最高的柱子 max(height[0..i]), # 右边最高的柱子 max(height[i..end]) ) - height[i] 基于此，暴力写法： 12345678910111213141516171819class Solution { public int trap(int[] height) { int n = height.length; int res = 0; for (int i = 1; i &lt; n - 1; i++) { int l_max = 0, r_max = 0; // 找右边最高的柱子 for (int j = i; j &lt; n; j++) r_max = Math.max(r_max, height[j]); // 找左边最高的柱子 for (int j = i; j &gt;= 0; j--) l_max = Math.max(l_max, height[j]); // 如果自己就是最高的话， // l_max == r_max == height[i] res += Math.min(l_max, r_max) - height[i]; } return res; }} 时间复杂度 O(N²)，空间复杂度 O(1)。但是很明显这种计算 r_max 和 l_max 的方式非常笨拙 备忘录优化开两个数组 r_max 和 l_max 充当备忘录，l_max[i] 表示位置 i 左边最高的柱子高度，r_max[i] 表示位置 i 右边最高的柱子高度。预先把这两个数组计算好，避免重复计算： 12345678910111213141516171819202122232425class Solution { public int trap(int[] height) { if (height.length == 0) { return 0; } int n = height.length; int res = 0; // 数组充当备忘录 int[] l_max = new int[n]; int[] r_max = new int[n]; // 初始化 base case l_max[0] = height[0]; r_max[n - 1] = height[n - 1]; // 从左向右计算 l_max for (int i = 1; i &lt; n; i++) l_max[i] = Math.max(height[i], l_max[i - 1]); // 从右向左计算 r_max for (int i = n - 2; i &gt;= 0; i--) r_max[i] = Math.max(height[i], r_max[i + 1]); // 计算答案 for (int i = 1; i &lt; n - 1; i++) res += Math.min(l_max[i], r_max[i]) - height[i]; return res; }} 把时间复杂度降低为 O(N)，已经是最优了，但是空间复杂度是 O(N) 双指针解法用双指针边走边算，节省下空间复杂度。 12345678910111213141516171819202122class Solution { public int trap(int[] height) { int left = 0, right = height.length - 1; int l_max = 0, r_max = 0; int res = 0; while (left &lt; right) { l_max = Math.max(l_max, height[left]); r_max = Math.max(r_max, height[right]); // res += min(l_max, r_max) - height[i] if (l_max &lt; r_max) { res += l_max - height[left]; left++; } else { res += r_max - height[right]; right--; } } return res; }} 对于下图的情况，我们已经知道 l_max &lt; r_max 了，至于这个 r_max 是不是右边最大的，不重要。重要的是 height[i] 能够装的水只和较低的 l_max 之差有关，所以此处自然计算的是 left 柱所能接收雨水： 拓展题目11. 盛最多水的容器 11. 盛最多水的容器 | 力扣 | LeetCode | 🟠 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 示例 1：12输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2：12输入：height = [1,1]输出：1 提示： n == height.length 2 &lt;= n &lt;= 10⁵ 0 &lt;= height[i] &lt;= 10⁴ 题目来源：力扣 11. 盛最多水的容器。 思路和接雨水问题很类似，可以完全套用前文的思路，而且还更简单。两道题的区别在于： 接雨水问题给出的类似一幅直方图，每个横坐标都有宽度，而本题给出的每个横坐标是一条竖线，没有宽度。 前文讨论了半天 l_max 和 r_max，实际上都是为了计算 height[i] 能够装多少水；而本题中 height[i] 没有了宽度，那自然就好办多了。 举个例子，如果在接雨水问题中，你知道了 height[left] 和 height[right] 的高度，你能算出 left 和 right 之间能够盛下多少水吗？ 不能，因为你不知道 left 和 right 之间每个柱子具体能盛多少水，你得通过每个柱子的 l_max 和 r_max 来计算才行。 反过来，就本题而言，你知道了 height[left] 和 height[right] 的高度，能算出 left 和 right 之间能够盛下多少水吗？ 可以，因为本题中竖线没有宽度，所以 left 和 right 之间能够盛的水就是： 1min(height[left], height[right]) * (right - left) 解决这道题的思路依然是双指针技巧： 双指针用 left 和 right 两个指针从两端向中心收缩，一边收缩一边计算 [left, right] 之间的矩形面积，取最大的面积值即是答案。 注意，收缩的操作本就是为了寻找更大的面积，所以应该把 left 和 right 更小的一边先进行收缩，期望能够找到更高的边代替，进而能够更新最大面积 123456789101112131415161718class Solution { public int maxArea(int[] height) { int left = 0, right = height.length - 1; int res = 0; while (left &lt; right) { // [left, right] 之间的矩形面积 int cur_area = Math.min(height[left], height[right]) * (right - left); res = Math.max(res, cur_area); // 双指针技巧，移动较低的一边 if (height[left] &lt; height[right]) { left++; } else { right--; } } return res; }}","link":"/2025/12/14/leetcode/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98-11%E3%80%8142/"},{"title":"0.介绍","text":"为什么？现在技术领域有较成熟的项目管理系统，如：禅道、TAPD，但其更多关注点在于需求迭代和缺陷本身，对项目资源管控以及流程引擎关注较少。因此可以考虑设计一款智能的项目管理系统，核心在于对项目资源录入、任务智能流转分配等方面，目标是建立完整的 CRM 系统，结合 LLM ，该项目将有无限可能。 怎么学？重点在技术架构、组件库开发、业务梳理上，针对产品设计也应该有所了解。 学什么？因为定时场景在真实业务中较为常见，所以首先选择定时微服务进行学习。","link":"/2025/12/20/project/%E5%BE%AE%E6%9C%8D%E5%8A%A1/0.%E4%BB%8B%E7%BB%8D/"},{"title":"1.准备","text":"价值在学习该项目前，应该对其价值有一个清晰的认识，明确学习该项目能够带来哪些提升。 优点 立意：在社区项目中经常会用到定时任务，比如定时进行数据同步、定时处理合并消息请求等，定时微服务可以很好地解决这些问题。因此除了直接调用类似 XXL-JOB 等定时模块，手动实现一个更加轻量化、可扩展的定时任务处理机制就更具有实际意义，有助于深入理解微服务架构设计。 属性：定时场景是一个通用且业务关联性弱的场景，适合做成微服务独立部署，或作为中台服务去维护。 核心：定时服务并不复杂，场景便于理解，但是重点在于定时的精度、任务的吞吐量等问题，能够锻炼对分布式系统的理解。 技术栈：在针对核心问题上，核心组件就是 MySQL、Redis、消息队列（作为异步回调能力）等，技术栈相对简单，便于快速上手。 价值重点在于架构能力的提高，定时微服务决定采用模块化设计、分治策略等设计理念，能够有效在核心问题上提供较好的解决方案。 背景与现状了解项目价值后，需要继续对项目在实际业务中出现的场景进行分析，明确项目的背景与现状。 场景 某类办公软件，每天早上9点通知员工打卡 订单下单15分钟后，若未支付则自动关闭订单 红包超时未领取，自动退回到账户余额 理解针对上述业务场景分析，会发现大多涉及一个定时/周期执行的情况，因此关于“定时”属性可以将其与业务属性剥离，形成类似“闹钟”的服务，至于唤醒某些业务后，需要其单独处理自己的业务逻辑。 现状定时场景在市面上有较多的解决方案，但实际上： 大多公司对于定时任务需求并不复杂，重点在于定时，为此引入功能强大但臃肿的任务调度组件是不合适的，前期学习成本、接入成本与后期维护成本都会偏高 且基于下述表格对比的结果来看，设计功能聚焦、接入轻量、维护成本低且支持动态灵活的任务定时/周期处理的微服务有一定意义 决定设计一款依赖简单、学习成本较低、性能较优的定时微服务 方案 介绍 特性 不足 Java Timer Java标准库中的定时器工具 1. 简单易用2. 基于单线程执行任务 • 单线程执行可能导致任务间相互影响• 不适合执行长时间运行的任务• 异常处理不足 RocketMq 分布式消息队列系统 1. 基于消息队列的定时任务执行2. 高可用性和可扩展性3. 支持延迟消息和定时消息 • 需要额外维护一个消息队列系统• 延迟精度可能受到网络延迟和系统负载的影响• 存在极小的消息丢失或重复消费的风险 其他公司内部实现 很多公司内部都有自定定时器的实现，但都只能内部使用，且服务设计多与内部业务特性挂钩 - • 仅面向团队内部使用 elastic-job-lite 轻量级分布式任务调度框架 1. 支持弹性扩展和任务分片2. 集成简单，配置丰富3. 基于ZooKeeper协调服务 • 依赖ZooKeeper作为协调服务，增加了系统复杂性• 对于简单的定时场景可能过于复杂 xxl-job 代表性的自定义任务调度工具 1. 可定制性强2. 可集成到现有应用3. 功能灵活 • 学习曲线可能陡峭• 可能需要额外开发和维护成本• 对于简单的定时任务需求过于复杂 Quartz 功能强大的任务调度框架 1. 灵活的任务调度2. 支持集群和持久化3. 可与数据库结合使用 • 配置和管理相对复杂• 资源消耗较大，特别是在大规模任务调度时• 对于简单的定时需求处理过于复杂 Robfig/Cron golang版本github上star最多的开源框架 1. 目前在github中的star最多，得到广泛的使用和测试，评级结果表明，与其他go开源框架相比，它拥有最高的调度准确性 • 设计用于在单个应用实例中执行定时任务• 不支持分布式任务调度• 缺乏任务执行结果的监控和告警机制 架构设计针对架构设计需要做到以下几点： 充足的准备工作：信息收集、技术调研 要有成套、成体系的方法论： 准备阶段：诉求摸底、请求量确认、精准性深究、重难点分析 设计阶段：上下游服务分析、存储选型、流程串联 优化阶段：设计复盘、潜在优化点 准备阶段 诉求摸底：摸清整体诉求，了解清楚是做什么、业务流程是怎样、核心功能点有哪些 请求量确认：根据实际QPS量级设计，避免过多、过少 精准性深究：分析定时任务的精准性要求，是否需要支持秒级、毫秒级的定时任务 重难点分析：分析定时任务中可能遇到的重难点问题，能够加深对设计的理解 设计阶段架构=服务+存储+流程，即有哪些需要提供的服务、存储用什么、业务流程如何把服务和存储串联起来 上下游服务针对定时微服务的分析，可能涉及的上下游服务较少。通常成型项目可能分为信息服务、库存服务、订单服务等。而定时微服务则主要负责处理定时任务，与其他服务进行交互时，通常只需要调用其提供的接口即可。 存储选型后端开发重要的职责是与数据打交道，因此在设计定时微服务时，需要考虑如何存储定时任务的相关信息。 存储的选型可以考虑到：存储场景、可靠性、性能要求、团队技术栈等因素。较为常用的自然是 MySQL、Redis 等。 流程串联在完成好服务设计、存储选型后，再考虑实际的数据流转流程，确保能够正常运行。 同时在该阶段就要考虑对难点、要点进行详细分析。核心问题：流程细节、高并发、高精准 优化阶段初步架构设计后，进行整体复盘与优化点考虑。 难点 - 高精准介绍定时场景的高精准问题指：预期设定的触发时间与实际触发时间之间的差值问题。即需要针对差值进行优化，越高的精准度适用的业务范围更广。 但难以做到毫秒级保证。因为整体是一个分布式的微服务，期间的网络调用、数据 IO、触发时机间隔等耗时导致的误差是无法避免的。只有单应用级别如Java timer 这种可以实现毫秒级别 常见差值原因 定时扫描：定时扫描任务队列并执行。周期如果是5分钟，那么最大延时误差就接近5分钟 基于消息队列实现的定时器：任务在队列中容易造成堆积，可能导致延时增加 基于分布式实现的定时器：当数据需要通过网络在不同组件中流转时，会引入网络延迟，导致延时增加 任务数据的查找延时：当一个任务的触发过程中涉及多次查改操作，如果数据存储不合理导致检索效率低，整体流程耗时自然增加（如索引不合适、缓存未击中） 同一时间任务量大：若在某一时间有大量定时任务需要出发，由于系统处理能力是有限的，任务处理必定有先有后，形成排队状态，会导致后处理的任务延时较高 总结几乎所有定时任务框架或消息队列，只支持秒级误差。因此针对精准度的优化是定时微服务的难点问题 难点- 高负载高负载：支持大量任务同时处理不积压 介绍真实的业务场景，如果定时微服务接入的业务越来越多，自然导致任务量的暴涨，进而导致的问题有： 数据库压力增大：任务信息存储在数据库中，若任务量增加，数据库的读写压力也会增加，可能导致数据库性能下降 内存占用增加：每个任务都需要占用一定的内存资源，若任务量增加，内存占用也会增加，可能导致内存不足 处理延迟增加：若系统处理能力有限，当任务量增加时，任务处理的延迟也会增加，可能导致任务触发时间与预期有较大误差 系统资源浪费：若系统资源（如CPU、网络带宽）有限，当任务量增加时，系统资源的利用效率可能会下降 分析针对高负载量，可以在以下几个方面考虑解决方案： 应用层减少任务量 业务方整合任务列表，减少对定时微服务的调用次数。即如果业务方在同一时间有多个任务要执行，那他应该将多个任务列成一个计划列表，然后为这个计划列表创建一个定时任务，而不是为计划里的每一项创建一个定时任务 分库分表 分库分表的基本概念是将一个大型数据库分成多个较小的数据库（分库），并将数据库的数据进一步分成多个较小的表（分表）。使得查询和更新操作可以并行在多个数据库与表之间并行执行，提高系统的拓展性和性能 常见分库分表策略： 垂直分表：将原始数据按照列拆分成多个表，每个表只包含某些列。常用于处理包含大量无关字段表 水平分表：将原始数据按照行拆分成多个表，每个表只包含部分行数据。常用于处理包含大量数据的表 分库分表组合：将垂直分表和水平分表结合起来使用，同时对数据库和表进行切分 数据分区 数据分区的思路其实跟分库分表理念类似，同样期望将数据进行拆分后提升并发度，提升检索效率。所以数据分区理念还可以运用在缓存数据等地方，如 Redis 数据同样进行分区设计等 线程池 由于定时微服务对数据库进行操作是一个 IO 流，所以可以基于线程池技术，采用多线程，为每个任务分配一个线程进行处理。 难点 - 任务异常介绍在实际业务中，对于定时服务至少有一个要求：必须要触发，尽管可能有时间误差。但实际情况可能导致任务无法正常运行，主要分为以下三种异常情况： 新建、激活接口异常：创建、激活任务接口发生异常。此时可以通过接口返回值反馈给用户，并可以通过主动重试等操作进行解决 任务流传异常：定时任务一般存储到数据库就算创建成功，后续如何确保任务消息能够顺利准时到达受方，就是定时微服务的职责，如果出现以下异常可能导致任务无法触发： 数据库异常：整个流转过程中会频繁发生数据库存取，期间若数据库异常，可能导致任务消息丢失 中间件存取异常：若将数据库任务缓存了一份到 Redis 中，那必定期间会发生很多 Redis 存取 任务出触发阶段异常：当任务进入触发阶段，需要回调业务方告知触发结果，如果回调失败，对于业务方来说同样属于任务执行失败 分析针对可能出现的问题可以考虑以下方案： 重试机制：如果是偶发性异常，如数据库抖动、Redis抖动等，这类异常是可以通过重试机制解决的 失败兜底机制：如果遇到重试无法解决的问题，如存储服务某个节点崩溃，正在进行替换，需要一定时间。这期间的任务需要标记为失败状态等待后续中间件恢复再重试。一般通过运行兜底的“定时脚本”任务，来处理这些失败任务，通常需要进行全盘扫描，运行成本较高 失败报警机制：如果任务失败次数超过一定阈值，需要及时报警通知相关人员，及时处理，主要针对无法再次运行成功的任务","link":"/2025/12/20/project/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1.%E5%87%86%E5%A4%87/"}],"tags":[{"name":"Introduction","slug":"Introduction","link":"/tags/Introduction/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"字典序","slug":"字典序","link":"/tags/%E5%AD%97%E5%85%B8%E5%BA%8F/"},{"name":"中等","slug":"中等","link":"/tags/%E4%B8%AD%E7%AD%89/"},{"name":"死锁","slug":"死锁","link":"/tags/%E6%AD%BB%E9%94%81/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"微服务， 定时微服务","slug":"微服务，-定时微服务","link":"/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8C-%E5%AE%9A%E6%97%B6%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"categories":[{"name":"Personal","slug":"Personal","link":"/categories/Personal/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"LeetCode","slug":"技术/LeetCode","link":"/categories/%E6%8A%80%E6%9C%AF/LeetCode/"},{"name":"Project","slug":"Project","link":"/categories/Project/"}],"pages":[{"title":"","text":"/* 文章目录样式 */ .article-toc { margin: 20px 0; padding: 16px; border: 1px solid #e5e7eb; border-radius: 8px; background-color: #f9fafb; } .article-toc h3 { margin-top: 0; margin-bottom: 12px; font-size: 16px; color: #1f2937; border-bottom: 1px dashed #d1d5db; padding-bottom: 8px; } .article-toc ul { padding-left: 20px; margin: 0; list-style: disc; } .article-toc li { margin: 6px 0; font-size: 14px; color: #4b5563; } .article-toc a { color: #3b82f6; text-decoration: none; } .article-toc a:hover { color: #2563eb; text-decoration: underline; }","link":"/css/custom.css"},{"title":"","text":"/** * 生成包含指定字符的 SVG 矢量图 * @param {string} text - 要显示的字符（如 \"ZALA13\"） * @param {Object} options - 可选配置（字体、颜色、尺寸等） * @returns {string} SVG 字符串 */ function generateTextSVG(text, options = {}) { // 默认配置 const config = { width: options.width || 300, // SVG 宽度 height: options.height || 150, // SVG 高度 fontSize: options.fontSize || 48, // 字体大小 fontFamily: options.fontFamily || 'Arial, Helvetica, sans-serif', // 字体 fill: options.fill || '#000000', // 字符颜色 stroke: options.stroke || 'none', // 描边（none 为无） strokeWidth: options.strokeWidth || 1, // 描边宽度 textAlign: options.textAlign || 'center', // 文字对齐方式 verticalAlign: options.verticalAlign || 'middle' // 垂直对齐 }; // 计算文字垂直居中的 y 坐标（SVG 中 y 轴向下，需结合字体大小计算） let y; if (config.verticalAlign === 'middle') { y = config.height / 2 + config.fontSize / 3.5; // 补偿字体基线偏移 } else if (config.verticalAlign === 'top') { y = config.fontSize; } else { y = config.height - 10; // bottom } // 拼接 SVG 字符串 const svg = ` ${text} `.trim(); return svg; } // ===================== 用法示例 ===================== // 1. 生成 \"ZALA13\" 的 SVG const zalaSvg = generateTextSVG(\"ZALA13\", { width: 400, // 自定义宽度 height: 200, // 自定义高度 fontSize: 60, // 更大的字体 fill: \"#2c3e50\", // 深蓝色文字 stroke: \"#ecf0f1\", // 浅灰色描边 strokeWidth: 2 // 描边宽度 }); // 2. 打印 SVG 内容（可直接复制到文本文件，保存为 .svg 格式） console.log(zalaSvg); // 3. 浏览器环境下：自动下载 SVG 文件（可选） if (typeof document !== 'undefined') { const blob = new Blob([zalaSvg], { type: 'image/svg+xml' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'ZALA13.svg'; // 下载的文件名 a.click(); URL.revokeObjectURL(url); // 释放资源 }","link":"/img/codeToSvg/svg-generator.js"}]}